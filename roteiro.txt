CPU profile

-> Escrever código ruim

-> Extrair profile manual
   -> runtime/pprof

-> Analisar profile
   -> interactive
   -> web
   -> callgrind
      -> brew install qcachegrind

-> Escrever benchmark
   -> Extrair profile do benchmark com go test -cpuprofile cpu.out -bench .
   -> Como testar também com o benchmark (StopTimer, StartTimer)
   -> Analisar profile do benchmark
   -> Salvar output do benchmark para comparação futura

$ go test -bench . -cpuprofile cpu.prof
testing: warning: no tests to run
BenchmarkOrderedListInsert-4      200000       1065027 ns/op
PASS
ok      github.com/cezarsa/perf 213.182s


-> Reescrever código, menos ruim, mas ainda ruim.
-> Nova rodada de benchmark

$ go test -bench . -cpuprofile cpu.prof
BenchmarkOrderedListInsert-4      100000        169606 ns/op
PASS
ok      github.com/cezarsa/perf 17.141s

-> Comparar benchmark
   -> go get golang.org/x/tools/cmd/benchcmp

$ benchcmp before.txt after.txt
benchmark                        old ns/op     new ns/op     delta
BenchmarkOrderedListInsert-4     1065027       169606        -84.07%

-> Analisar novo profile
   -> Nada de útil, e agora?

--- Desvio no caminho ---

-> Transformar em app web
-> Usar net/http/pprof
-> Rodar wrk e fazer profiling cpu
   -> Nada de útil novamente

--- Heap profiling ---

-> 4 em 1. falar dos dois tipos, alloc e inuse

-> Rodar benchmark novamente com -benchmem
